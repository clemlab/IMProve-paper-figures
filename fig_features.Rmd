---
title: "Data munging and figure preparation"
author: "Shyam Saladi (saladi@caltech.edu)"
date: "09/20/2016"
output: html_document
---

## Load libraries
Load all libraries necessary for subsequent data munging and plotting.
Some defaults are set here to make things easier throughout.
```{r libraries}
# if TRUE, then data will be written to file
write_out = FALSE

library(iterators)
library(magrittr)
library(tidyverse)
library(dplyrExtras)

library(caret)
library(pROC)
library(datamart) # `uconv` for unit conversion
library(cowplot)
library(corrplot)
library(RColorBrewer)
library(viridis)
theme_set(theme_cowplot(font_size = 7))

library(parallel)
# currently provisioned resources
# cl <- c("brnode05", "brnode07", "brnode08") %>%
#     rep(20) %>%
#     c(rep("brnode11", 44)) %>%
#     makeCluster()

library(foreach)
library(doMC)
registerDoMC(cores = 20L)
#
# library(doParallel)
# registerDoParallel(cl)

# devtools::install("myutils")
library(myutils)
## ggcorr modified from ggcorr package
```

### Load data from training process
```{r}
training_env <- new.env()
load("training.RData", training_env)
```

### Load model data for prediction function
```{r}
model_env <- new.env()
load("model.RData", model_env)
svmpredict <- model_env$svmpredict
```

### Load NYCOMPS data for prediction function
```{r}
nycomps_env <- new.env()
load("large-scale.Rdata", nycomps_env)
```

### Define auc function for the subsequent calculations
```{r}
auc_w_ci <- partial(ci.auc, direction = "<",
                    method = "delong"#,
                    # boot.n = 1000,
                    # progress = "none",
                    # parallel = TRUE
                    )
```

## Load SVM weights and calculate correlations
This block loads a csv file of the model's weights and renames certain features
whose original identifiers could be more accurately written by the feature
calculation Python scripts.
```{r load_weights}
# name corrections (see smsaladi/ml-expression#16)
rename_feats <- function(df) {
    rename(df,
           avgCU_first5 = minCU_win5,
           avgCU_first10 = minCU_win10,
           nterm_hydOCT = nterm_hydGES,
           avgRONNTM1_2 = RONNlongestloop,
           RONNlongestloop = avgRONNTM1_2)
}

# load weights
svmweights <- model_env$svm_model %>%
    enframe(name = "old_name", value = "weight") %>%
    mutate(abs_weight = abs(weight),
           rel = weight / mean(weight)) %>%
    inner_join(read_csv("training/feature_key.csv"), by = "old_name")
```

## Calculate feature correlations
Calculates the Pearson correlation coefficients between each feature within a
reference dataset, i.e. all forward predicted genomes.
```{r feature_correlation}
# correlation matrix for forward predicted genomes
nycomps_cor <- nycomps_env$nycomps_features %>%
    select(-score, -score_nornass) %>%
    preprocess_vars(model_env$daley_preprocess_params) %>%
    rename_feats

# significance test for correlation matrix
# from corrplot::corplot-intro vignette
nycomps_cor_mtest <- nycomps_cor %>%
    cor.mtest

nycomps_cor %<>%
    cor(use = "pairwise.complete.obs")

# boxes for groupings/orderings
svmweights <- nycomps_dendro %>%
    cutree(k = 11) %>%
    data.frame %>%
    rownames_to_column %>%
    right_join(svmweights, by = c("rowname" = "feature")) %>%
    rename_(cluster = as.name("."),
            feature = "rowname")

# Add feature groupings back to feature weights dataframe
# with manual category summary information (i.e. number of
# features that compose the grouping).
svmweights <- svmweights %>%
    group_by(category) %>%
    summarize(man_weight = sum(abs(weight)),
              man_count = n()) %>%
    right_join(svmweights, by = c("category")) %>%
    mutate(man_rank = dense_rank(-man_weight),
           man_alpha = LETTERS[man_rank])
```

# order of labels throughout figure
```{r}
category_color <- svmweights %>%
    group_by(prot_nuc, category) %>%
    summarize(weight = sum(weight)) %>%
    arrange(weight) %>%
    mutate_rows(prot_nuc == "Nucleotide",
                prot_nuc = brewer.pal(5, "Dark2")[[5]]) %>%
    mutate_rows(prot_nuc == "Protein",
                prot_nuc = brewer.pal(7, "Dark2")[[7]]) %$%
    setNames(prot_nuc, category)
```

# correlations between feature groups after adding by feature weights
```{r}
p_feat_category_corr <- nycomps_env$nycomps_features %>%
    semi_join(nycomps_env$nycomps_gene_outcomes, "id")

p_feat_category_corr <- p_feat_category_corr %>%
    transform_features(svmweights) %>%
    bind_cols(p_feat_category_corr %>% select(id)) %>%
    gather(feature, value, -id) %>%
    left_join(svmweights %>% select(category, old_name),
              by = c("feature" = "old_name")) %>%
    group_by(id, category) %>%
    summarize(value = sum(value, na.omit = TRUE)) %>%
    spread(category, value) %>%
    ungroup

p_feat_category_corr <-
    p_feat_category_corr[, names(category_color)] %>%
    ggcorr(method = c("pairwise.complete.obs", "pearson"),
           hjust = 1, size = 2,
           diagColors = svmweights %>%
           distinct(prot_nuc, category) %>%
           rename(feature = category,
                  colorgrp = prot_nuc) %>%
           data.frame
           ) +
    labs(fill = "Pearson's r") +
    theme(legend.position = c(-.07, .83),
          legend.title = element_text(size = 6),
          legend.text = element_text(size = 5),
          legend.key.height = unit(5, "pt"),
          legend.key.width = unit(8, "pt"),
          plot.margin = unit(rep(0, 4), "pt")) +
    scale_color_manual(values = setNames(brewer.pal(7, "Dark2")[c(5, 7)],
                                         c("Nucleotide", "Protein")),
                       guide = FALSE) +
    scale_fill_gradient2(breaks = c(-1, 0, 1), limits = c(-1, 1),
        guide = guide_colourbar(title = "Pearson's r",
                                title.position = "top",
                                title.hjust = 0.5,
                                nbin = 100,
                                raster = FALSE,
                                direction = "horizontal",
                                ticks = FALSE))

p_feat_category_corr %<>% ggplot_build %>% ggplot_gtable
p_feat_category_corr$layout$clip <- "off"

ggdraw(p_feat_category_corr)
```


```{r}
geom_bar_def <-
    partial(geom_bar, position = "stack", stat = "identity",
            width = 0.5, size = 0.5, fill = "white", color = "black")

p_weight_man_sum <- svmweights %>%
    group_by(category) %>%
    summarize(count = n(),
              tot_weight = sum(weight)) %>%
    ggplot(aes(x = category, y = weight)) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "lightgrey") +
    geom_bar_def(data = svmweights %>%
                     filter(weight > 0)) +
    geom_bar_def(data = svmweights %>%
                     filter(weight <= 0)) +
    geom_text(aes(y = 1.6, label = count), size = 5*5/14) +
    geom_point(aes(y = tot_weight), color = "red") +
    ylab("Weight") +
    scale_x_discrete(limits = names(category_color)) +
    coord_flip() +
    theme(legend.position = "none",
          axis.title.y = element_blank(),
          axis.text.y = element_text(color = category_color),
          plot.margin = unit(rep(0, 4), "pt"))

p_weight_man_sum %<>% ggplot_build %>% ggplot_gtable
p_weight_man_sum$layout$clip <- "off"

ggdraw(p_weight_man_sum)
```

## plot AUC within NYCOMPS with subsets of features
```{r nycomps_subsets}
transform_features <- function(ref_feat, weights) {
    # scale and center features
    feat_weights <- setNames(weights$weight, as.character(weights$old_name))
    trans_feat <- preprocess_vars(ref_feat, model_env$daley_preprocess_params)
    # reorder vector
    feat_weights <- feat_weights[colnames(trans_feat)]
    for (i in seq_along(trans_feat))
        set(trans_feat, j = i, value = trans_feat[[i]] * feat_weights[i])

    trans_feat[is.na(trans_feat)] <- 0

    trans_feat
}

calc_auc_feat_subsets <-
    function(use_feat_col, order_name, ref_feat, ref_eval, weights) {
        order_fun <- switch(order_name,
                            desc = great_eq,
                            incr = less_eq,
                            eq = eq_fun,
                            ne = ne_fun)
    trans_feat <- transform_features(ref_feat, weights)

    foreach(thisiter = weights %>%
                distinct_(use_feat_col) %>%
                unlist(use.names = FALSE),
            .combine = bind_rows, .multicombine = TRUE,
            .packages = c("pROC", "tidyverse"),
            .export = c("auc_w_ci", "trans_feat", "weights", "use_feat_col",
                        "order_fun", "ref_eval", "order_name"),
            .verbose = FALSE) %dopar% {
                # specify those features to use
                # can't seem to work out NSE, so this clumsy way right now
                use_feats <-
                    weights[order_fun(thisiter, weights[,use_feat_col]),] %>%
                    select(old_name) %>%
                    unlist(use.names = FALSE) %>%
                    as.character

                # prediction
                preds <- trans_feat[, use_feats, drop = FALSE] %>% rowSums

                # calculate auc
                data_frame(score = auc_w_ci(response = ref_eval,
                                            predictor = preds),
                           ci_labels = c("lower95", "auc", "upper95"),
                           iter = as.character(thisiter),
                           feat_count = length(use_feats))
            } %>%
        spread(ci_labels, score) %>%
        mutate(order_name = order_name,
               use_feat_col = use_feat_col)
}
```

```{r}
# auc combinations to test
feat_subset_combos <-
    # expand.grid(
    # use_feat_col = c("abs_weight", "man_weight"),
    # order_name = c('desc', 'incr', 'eq')) %>%
    bind_rows(expand.grid(
        use_feat_col = c('category',
                         'feature'),
        order_name = c('eq', 'ne'),
        stringsAsFactors = FALSE
    )) %>%
    bind_rows(data_frame(use_feat_col = 'prot_nuc', order_name = "eq"))

# gene level outcomes
feat_subset_auc <- feat_subset_combos %>%
    rowwise() %>%
    do({
        calc_auc_feat_subsets(
            use_feat_col = .$use_feat_col,
            order_name = .$order_name,
            ref_feat = nycomps_env$nycomps_gene_outcomes %>%
                left_join(nycomps_env$nycomps_features, by = "id"),
            ref_eval = nycomps_env$nycomps_gene_outcomes$posmix_outcome,
            weights = svmweights)
        }) %>%
    mutate(dataset = "posmix")
```

```{r}
# all outcomes
feat_subset_auc <- feat_subset_combos %>%
    rowwise() %>%
    do({
        calc_auc_feat_subsets(
            use_feat_col = .$use_feat_col,
            order_name = .$order_name,
            ref_feat = nycomps_env$nycomps_all_outcomes %>%
                left_join(nycomps_env$nycomps_features, by = "id"),
            ref_eval = nycomps_env$nycomps_all_outcomes$plasmid_outcome == 1,
            weights = svmweights)
        }) %>%
    mutate(dataset = "vectors") %>%
    bind_rows(feat_subset_auc, .)

# by vector
feat_subset_auc <- nycomps_env$nycomps_all_outcomes %>%
    rename(dataset = plasmid_name) %>%
    group_by(dataset) %>%
    do({
        df_feat <- left_join(., nycomps_env$nycomps_features, by = "id")
        feat_subset_combos %>%
            rowwise() %>%
            do({
                calc_auc_feat_subsets(
                    use_feat_col = .$use_feat_col,
                    order_name = .$order_name,
                    ref_feat = df_feat,
                    ref_eval = df_feat$plasmid_outcome == 1,
                    weights = svmweights)
                })
        }) %>%
    bind_rows(feat_subset_auc, .)
```

```{r}
nycomps_env$nycomps_all_outcomes %>%
    group_by(plasmid_name) %>%
    summarize(count = n()) %>%
    arrange(desc(count))
```

## capture model's AUC
```{r}
model_auc <- nycomps_env$nycomps_all_outcomes %>%
    rename(dataset = plasmid_name) %>%
    group_by(dataset) %>%
    do({
        auc_w_ci(response = .$plasmid_outcome == 1,
                 predictor = .$score) %>%
            data_frame(score = .,
                       ci_labels = c("lower95", "auc", "upper95"))
    })

model_auc <- nycomps_env$nycomps_gene_outcomes %$%
    auc_w_ci(response = posmix_outcome,
             predictor = score) %>%
    data_frame(score = .,
               ci_labels = c("lower95", "auc", "upper95")) %>%
    mutate(dataset = "posmix") %>%
    bind_rows(model_auc) %>%
    spread(ci_labels, score)
```

## indiv weights
```{r}
feature_order <- feat_subset_auc %>%
    filter(order_name == "eq", dataset == "posmix",
           use_feat_col == "feature") %>%
    arrange(desc(as.numeric(auc))) %$%
    unlist(iter, use.names = FALSE) %>%
    c("SVMrank Score", .) %>%
    factor(., ., ordered = TRUE)

feat_subset_auc %>%
    filter(order_name == "eq", use_feat_col == "feature",
           dataset != "posmix", dataset != "vectors") %>%
 #   bind_rows(model_auc %>% mutate(iter = "SVMrank Score")) %>%
    mutate(iter = factor(iter, feature_order, ordered = TRUE)) %>%
    ggplot() +
    geom_hline(yintercept = 0.5, linetype = "dashed") +
    geom_pointrange(aes(x = "SVMrank Score",
                        y = auc, ymin = lower95, ymax = upper95),
                    color = "lightgray", size = 0.5, fatten = 0.5,
                    data = model_auc %>% filter(dataset != "posmix")) +
    geom_pointrange(aes(x = "SVMrank Score",
                        y = auc, ymin = lower95, ymax = upper95),
                    color = "#A10F1C", size = 1, fatten = 1,
                    data = model_auc %>% filter(dataset == "posmix")) +
    geom_pointrange(aes(x = iter, y = auc, ymin = lower95, ymax = upper95),
                    color = "lightgray", size = 0.5, fatten = 0.5) +
    geom_pointrange(aes(x = iter, y = auc, ymin = lower95, ymax = upper95),
                    color = "#A10F1C", size = 0.5, fatten = 0.5,
               data = feat_subset_auc %>%
                   filter(order_name == "eq",
                          use_feat_col == "feature",
                          dataset == "posmix")) +
    coord_flip() +
    #coord_cartesian(ylim = c(0.35, 0.65)) +
    ylab("AUC") +
    scale_x_discrete(limits = feature_order %>% rev) +
    scale_y_continuous(expand = c(0,0), labels = function(x)x*100) +
    theme(legend.position = "none",
          axis.title.y = element_blank(),
          plot.margin = unit(c(0, 0, 0, 0), "pt"))
```

```{r}
category_color %<>%
    c(`SVMrank Score` = "#000000", .) %>%
    rev

make_incl_excl <- function(df)
    df %>%
    filter(use_feat_col == "category",
           dataset != "posmix", dataset != "vectors") %>%
    ggplot() +
    geom_hline(yintercept = 0.5, linetype = "dashed") +
    geom_pointrange(aes(x = "SVMrank Score",
                        y = auc, ymin = lower95, ymax = upper95),
                    color = "lightgray", size = 0.5, fatten = 0.5,
                    data = model_auc %>% filter(dataset != "posmix")) +
    geom_pointrange(aes(x = "SVMrank Score",
                        y = auc, ymin = lower95, ymax = upper95),
                    color = "#A10F1C", size = 1, fatten = 1,
                    data = model_auc %>% filter(dataset == "posmix")) +
    geom_pointrange(aes(x = iter, y = auc, ymin = lower95, ymax = upper95),
                    color = "lightgray", size = 0.5, fatten = 0.5) +
    geom_pointrange(aes(x = iter, y = auc, ymin = lower95, ymax = upper95),
                    color = "#A10F1C", size = 0.5, fatten = 0.5,
               data = df %>%
                   filter(use_feat_col == "category", dataset == "posmix")) +
    ylab("AUC") +
    scale_y_continuous(limits = c(.16, .86), breaks = seq(0, 1, .2),
                       labels = function(x) x*100,) +
    scale_x_discrete(limits = names(category_color)) +
    coord_flip() +
    theme(legend.position = "none",
          axis.text.y = element_text(color = category_color),
          axis.title.y = element_blank(),
          strip.text = element_blank(),
          strip.background = element_blank(),
          plot.margin = unit(rep(0, 4), "pt"))

p_category_incl <- feat_subset_auc %>%
    filter(order_name == "eq") %>%
    make_incl_excl %>%
    ggdraw +
    draw_plot_label("Only Single\nCategory", x = .23, y = .92,
                    fontface = "bold", size = 6, hjust = 0, vjust = 0)

p_category_excl <- feat_subset_auc %>%
    filter(order_name == "ne") %>%
    {make_incl_excl(.) +
         theme(axis.text.y = element_blank())} %>%
    ggdraw +
    draw_plot_label("Excluding Single\nCategory", x = .02, y = .92,
                    fontface = "bold", size = 6, hjust = 0, vjust = 0)

p_category_incl
p_category_excl
```


```{r}
p_weight_protnuc <- svmweights %>%
    group_by(prot_nuc) %>%
    summarize(
        count = n(),
        tot_weight = sum(weight)) %>%
    ggplot(aes(x = prot_nuc, y = weight)) +
    geom_bar_def(data = svmweights %>%
                     filter(weight > 0)) +
    geom_bar_def(data = svmweights %>%
                     filter(weight <= 0)) +
    geom_text(aes(y = 7, label = count),
              size = 5*5/14) +
    geom_point(aes(y = tot_weight), color = "red") +
    ylab("Weight") +
    coord_flip() +
    theme(axis.title.y = element_blank(),
          axis.text.y =
              element_text(color = brewer.pal(7, "Dark2")[c(5, 7)]),
          plot.margin = unit(rep(0, 4), "pt"))

p_weight_protnuc %<>% ggplot_build %>% ggplot_gtable
p_weight_protnuc$layout$clip <- "off"

ggdraw(p_weight_protnuc)
```

# protein or nucleotide auc plot
```{r}
p_auc_protnuc <- feat_subset_auc %>%
    filter(use_feat_col == "prot_nuc", order_name == "eq")

p_auc_protnuc <- p_auc_protnuc %>%
    filter(dataset != 'vectors', dataset != 'posmix') %>%
    ggplot() +
    geom_hline(yintercept = 0.5, linetype = "dashed") +
    geom_pointrange(aes(x = "SVMrank",
                        y = auc, ymin = lower95, ymax = upper95,
                        group = dataset),
                    position = position_dodge(width = 0.5),
                    color = "lightgray", size = 0.5, fatten = 0.5,
                    data = model_auc %>% filter(dataset != "posmix")) +
    geom_pointrange(aes(x = "SVMrank",
                        y = auc, ymin = lower95, ymax = upper95),
                    color = "#A10F1C", size = 1, fatten = 1,
                    data = model_auc %>% filter(dataset == "posmix")) +
    geom_pointrange(aes(x = iter, y = auc, ymin = lower95, ymax = upper95,
                        group = dataset),
                    position = position_dodge(width = 0.5),
                    color = "lightgray", size = 0.5, fatten = 0.5) +
    geom_pointrange(aes(x = iter, y = auc, ymin = lower95, ymax = upper95),
                    color = "#A10F1C", size = 0.5, fatten = 0.5,
                    data = p_auc_protnuc %>% filter(dataset == "posmix")) +
    ylab("AUC") +
    scale_y_continuous(expand = c(0, 0), limits = c(.16, .86),
                       labels = function(x) x*100) +
    scale_x_discrete(limits = c("Nucleotide", "Protein", "SVMrank"),
                     labels = c(Nucleotide = "Nucleotide\nOnly",
                                Protein = "Protein\nOnly",
                                SVMrank = "SVMrank\nScore")) +
    coord_flip() +
    theme(legend.position = "none",
          axis.text.y = element_text(
              color = c(brewer.pal(7, "Dark2")[c(5, 7)], "#000000")),
          axis.title.y = element_blank(),
          plot.margin = unit(rep(0, 4), "pt"))

p_auc_protnuc
```

### Load data from training process
```{r}
training_env <- new.env()
load("training.RData", training_env)
```

## Load Fluman, et al., aSD mutant data (Figure 6 in their paper)
```{r fluman_data_prep, cache=TRUE}
fluman_asd <- read_csv("forward-genomes/fluman_asd_mutant.fna.allstats.csv") %>%
    separate(title, c("gene")) %>%
    mutate(gene = tolower(gene),
           construct = "MUT")

fluman_asd <- training_env$daley_allstats %>%
    filter(id %in% fluman_asd$gene) %>%
    rename(gene = id) %>%
    mutate(construct = "WT") %>%
    bind_rows(fluman_asd)

fluman_asd$score <- svmpredict(fluman_asd)

fluman_asd <- read_csv("forward-genomes/fig6-analysis.csv") %>%
    filter(band == "FOLDED") %>%
    rename(outcome = `Area from Image`) %>%
    mutate(gene = tolower(gene)) %>%
    select(-`Percent (Just an identifier)`, -band) %>%
    left_join(fluman_asd, by = c("gene", "construct")) %>%
    gather(metric, value, -gene, -construct) %>%
    spread(construct, value) %>%
    mutate(rel_diff = rel_diff(MUT, WT))
```

# fluman asd plotting
```{r fluman_asd_plotting}
metrics_of_interest <- data.frame(
    row.names = c("SD-like Sites",  "Folded Protein", "SVMrank Score"),
    colors = c("#e7298a", "#7570b3", "#e6ab02"),
    short = c("totalSDsites", "outcome", "score")) %>% t

p4_fluman_asd <- fluman_asd %>%
    filter(metric %in% metrics_of_interest['short',]) %>%
    mutate(gene = factor(gene,
                         levels = c("ygdd", "brnq", "ybjj"),
                         labels = c("YgdD", "BrnQ", "YbjJ")),
           metric = factor(metric,
                           levels = metrics_of_interest['short',],
                           labels = colnames(metrics_of_interest))) %>%
    ggplot(aes(x = gene, y = rel_diff, fill = metric)) +
    geom_bar(stat = "identity", position = "dodge") +
    ylab("Relative Difference") +
    scale_fill_manual(values = metrics_of_interest['colors',]) +
    scale_y_continuous(labels = c(-1, -.5, 0, .25)) +
    theme(axis.title.x = element_blank(),
          legend.title = element_blank(),
          legend.key = element_blank(),
          legend.key.size = unit(0.25, "cm"),
          legend.position = c(.60, .23),
          plot.margin = unit(rep(0, 4), "pt"))

p4_fluman_asd %<>% ggplotGrob()

# remove keystones and set legend text label colors

for (idx in c(4L, 6L, 8L))
    p4_fluman_asd$grobs[[8L]]$grobs[[1L]]$grobs[[idx]] <- zeroGrob()

p4_fluman_asd$grobs[[8L]]$grobs[[1L]]$grobs[[9L]]$gp$col <-
    metrics_of_interest['colors', 'SD-like Sites']

p4_fluman_asd$grobs[[8L]]$grobs[[1L]]$grobs[[10L]]$gp$col <-
    metrics_of_interest['colors', 'Folded Protein']

p4_fluman_asd$grobs[[8L]]$grobs[[1L]]$grobs[[11L]]$gp$col <-
    metrics_of_interest['colors', 'SVMrank Score']

ggdraw(p4_fluman_asd)
```


## Figure importance plot
This block plots the entire figure relating to feature importances.
```{r plot_feature_importances}
plt_lab <- partial(draw_plot_label, size = 8)

p5_weight_importance <-
    ggdraw() +
    draw_plot(p_weight_man_sum, x = .34, y = .7, width = .66, height = .3) +
    draw_plot(p_feat_category_corr,
              x = 0.05, y = .71, width = .29, height = .29) +
    draw_plot(
        plot_grid(p_category_incl, p_category_excl,
                  nrow = 1L, rel_widths = c(2.6, 2)),
        x = 0, y = .21, width = 1, height = .49) +
    draw_plot(
        plot_grid(p_weight_protnuc, p_auc_protnuc, p4_fluman_asd, nrow = 1,
                  align = "h", rel_widths = c(2, 2, 1),
                  labels = letters[5:7], label_size = 8, vjust = 0.5),
        x = 0, y = 0, width = 1, height = .2) +
    plt_lab(x = 0, y = 1, label = "a") +
    plt_lab(x = .31, y = 1, label = "b") +
    plt_lab(x = 0, y = .71, label = "c") +
    plt_lab(x = 0.53, y = .71, label = "d")
    # plt_lab(x = 0, y = .22, label = "e") +
    # plt_lab(x = 0.53, y = .22, label = "f")

p5_weight_importance %<>% ggplotGrob

# dont clip e, f, g labels
p5_weight_importance$grobs[[4]]$children[[5]]$children$layout$layout %<>%
    mutate_rows(name == "panel", clip = "off")

#if (write_out) {
    save_plot(filename = "plots/fig6_fluman.pdf", plot = p5_weight_importance,
          base_width = uconv(183, "mm", "in", "Length"),
          base_height = 5.5)
#}
ggdraw(p5_weight_importance)
```

## clustering of entire forward genomes
 `corrplot` is used to generate plot the correlation matrix becuase it more
feature-rich than equvilient ggplot-compatible packages. As a result, the panel
is saved and stiched together with the others after-the-fact using Adobe
Illustrator.
```{r plot_big_clustering}
if (write_out)
    pdf("plots/forward_corr.pdf", width = 10, height = 10)
# `corrplot` returns the correlation matrix re-ordered after clustering as
# plotted. Save this for the weights plot (chunk below).
forward_cor_clust <-
    corrplot(forward_cor, col = viridis(100),
             method = "square", plotCI = "n",
             order = "hclust", hclust.method = "complete",
             p.mat = forward_cor_mtest[[1]], sig.level = 0.05, insig = "blank",
             lowCI.mat = forward_cor_mtest[[2]],
             uppCI.mat = forward_cor_mtest[[3]],
             tl.cex = .5, tl.col = "black", tl.srt = 45)
if (write_out)
    dev.off()
```

## Plot weights
This block plots the weights for the SVM model trained in the order of the
hclust clustering of the correlation matrix (plotted directly above).
```{r plot_weights}
feat_order <- dimnames(forward_cor_clust)[[1]] %>% rev
p_svmweights <- svmweights %>%
    # these were not calculated across the full forward genomes set
    filter(!(feature %in% c("avgRNAss", "minRNAss", "maxRNAss",
                            "q75RNAss", "q25RNAss"))) %>%
    mutate(feature =
               factor(feature, labels = feat_order, levels = feat_order)) %>%
    na.omit %>%
    ggplot() +
    geom_bar(aes(x = feature, y = weight), stat = "identity") +
    ylab(expression("SVM" ^ "rank"*~"score")) +
    coord_flip() +
    theme(axis.title.y = element_blank())

if (write_out) {
    save_plot("plots/svmweights.pdf", p_svmweights,
              base_height = 10, base_width = 3)
} else {
    p_svmweights
}
```

```{r session}
if (write_out)
    save.image("fig_features.Rdata")
sessionInfo()
```
